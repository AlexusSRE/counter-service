<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pac-Man</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #0a0a1a;
      font-family: 'Segoe UI', sans-serif;
      color: #ffd700;
    }
    h1 {
      margin-bottom: 12px;
      font-size: 2rem;
      text-shadow: 0 0 12px #ffd700;
    }
    .info {
      display: flex;
      gap: 24px;
      margin-bottom: 12px;
      font-size: 1.1rem;
    }
    #canvas {
      display: block;
      background: #000;
      border: 4px solid #ffd700;
      border-radius: 8px;
      box-shadow: 0 0 24px rgba(255, 215, 0, 0.4);
    }
    .hint {
      margin-top: 12px;
      color: #888;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <h1>PAC-MAN</h1>
  <div class="info">
    <span>Score: <strong id="score">0</strong></span>
    <span>Lives: <strong id="lives">3</strong></span>
  </div>
  <canvas id="canvas" width="448" height="496"></canvas>
  <p class="hint">Arrow keys to move · Collect dots · Avoid ghosts!</p>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const TILE = 16;
    const COLS = 28;
    const ROWS = 31;

    // Simple maze: 0=empty, 1=wall, 2=dot, 3=power pellet
    const maze = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
      [1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,3,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
      [0,0,0,0,0,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,0,0,0,0,0],
      [1,1,1,1,1,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,1,1,0,1,1,1,0,0,1,1,1,0,1,1,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,2,1],
      [1,2,2,2,1,1,2,2,2,0,1,0,0,0,0,0,0,1,0,2,2,2,1,1,2,2,2,1],
      [1,1,1,2,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,2,1,1,1],
      [0,0,0,2,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,2,0,0,0],
      [1,1,1,2,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,2,1,1,1],
      [1,2,2,2,2,2,2,2,2,0,2,2,2,1,1,2,2,2,0,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,2,1],
      [1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1],
      [1,1,1,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,2,1,1,1,1],
      [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ];

    // Flatten for easier indexing (pad to 31 rows)
    while (maze.length < ROWS) maze.push(Array(COLS).fill(1));
    const grid = maze;

    let pacman = { x: 14, y: 22, dir: 0, mouth: 0 };
    const ghosts = [
      { x: 13, y: 14, color: '#f00', dir: 0 },
      { x: 14, y: 14, color: '#ffb8ff', dir: 1 },
      { x: 13, y: 12, color: '#00ffff', dir: 2 },
    ];
    let score = 0, lives = 3;
    let keys = {};
    let gameOver = false;
    let win = false;

    function px(c) { return c * TILE + TILE / 2; }

    function getTile(x, y) {
      const col = Math.floor(x / TILE);
      const row = Math.floor(y / TILE);
      if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return 1;
      return grid[row][col];
    }

    function canMove(nx, ny) {
      const t = getTile(nx * TILE, ny * TILE);
      return t !== 1;
    }

    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
    });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    function movePacman() {
      let nx = pacman.x, ny = pacman.y;
      if (keys['ArrowLeft']) { pacman.dir = 0; nx--; }
      if (keys['ArrowRight']) { pacman.dir = 1; nx++; }
      if (keys['ArrowUp']) { pacman.dir = 2; ny--; }
      if (keys['ArrowDown']) { pacman.dir = 3; ny++; }
      if (canMove(nx * TILE, ny * TILE)) {
        pacman.x = nx;
        pacman.y = ny;
      }
      pacman.mouth = (pacman.mouth + 0.2) % (Math.PI * 2);

      const row = pacman.y, col = pacman.x;
      if (grid[row] && grid[row][col] === 2) {
        grid[row][col] = 0;
        score += 10;
      }
      if (grid[row] && grid[row][col] === 3) {
        grid[row][col] = 0;
        score += 50;
      }
    }

    function moveGhost(g) {
      const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
      const choices = dirs
        .map((d, i) => ({ dx: d[0], dy: d[1], i }))
        .filter(({ dx, dy }) => canMove((g.x + dx) * TILE, (g.y + dy) * TILE));
      if (choices.length === 0) return;
      const pick = choices[Math.floor(Math.random() * choices.length)];
      g.x += pick.dx;
      g.y += pick.dy;
      g.dir = pick.i;
    }

    function checkCollision() {
      for (const g of ghosts) {
        if (Math.abs(g.x - pacman.x) < 0.5 && Math.abs(g.y - pacman.y) < 0.5) {
          lives--;
          document.getElementById('lives').textContent = lives;
          pacman.x = 14; pacman.y = 22;
          if (lives <= 0) gameOver = true;
        }
      }
    }

    function dotsLeft() {
      let n = 0;
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++)
          if (grid[r][c] === 2 || grid[r][c] === 3) n++;
      return n;
    }

    function draw() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let r = 0; r < ROWS; r++) {
        if (!grid[r]) continue;
        for (let c = 0; c < COLS; c++) {
          const x = c * TILE, y = r * TILE;
          if (grid[r][c] === 1) {
            ctx.fillStyle = '#2044aa';
            ctx.strokeStyle = '#4a6aff';
            ctx.lineWidth = 2;
            ctx.fillRect(x + 1, y + 1, TILE - 2, TILE - 2);
            ctx.strokeRect(x + 1, y + 1, TILE - 2, TILE - 2);
          } else if (grid[r][c] === 2) {
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(x + TILE/2, y + TILE/2, 2, 0, Math.PI * 2);
            ctx.fill();
          } else if (grid[r][c] === 3) {
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(x + TILE/2, y + TILE/2, 5, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      const angle = [Math.PI, 0, -Math.PI/2, Math.PI/2][pacman.dir];
      const open = Math.PI * 0.4 * Math.sin(pacman.mouth) + Math.PI * 0.3;
      ctx.fillStyle = '#ffd700';
      ctx.beginPath();
      ctx.arc(px(pacman.x), px(pacman.y), 6, angle - open, angle + open);
      ctx.lineTo(px(pacman.x), px(pacman.y));
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.stroke();

      ghosts.forEach(g => {
        ctx.fillStyle = g.color;
        ctx.beginPath();
        ctx.arc(px(g.x), px(g.y), 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(px(g.x) - 2, px(g.y) - 2, 2, 0, Math.PI * 2);
        ctx.arc(px(g.x) + 2, px(g.y) - 2, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#00f';
        ctx.beginPath();
        ctx.arc(px(g.x) - 2, px(g.y) - 2, 1, 0, Math.PI * 2);
        ctx.arc(px(g.x) + 2, px(g.y) - 2, 1, 0, Math.PI * 2);
        ctx.fill();
      });

      document.getElementById('score').textContent = score;
    }

    let ghostTick = 0;
    function loop() {
      if (gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f00';
        ctx.font = 'bold 32px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
        return;
      }
      if (dotsLeft() === 0) {
        win = true;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 32px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('YOU WIN!', canvas.width/2, canvas.height/2);
        return;
      }
      movePacman();
      ghostTick++;
      if (ghostTick % 4 === 0) ghosts.forEach(moveGhost);
      checkCollision();
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
    });
  </script>
</body>
</html>
