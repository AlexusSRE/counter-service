name: Infrastructure Bootstrap

on:
  workflow_dispatch:
    inputs:
      destroy:
        description: "Type 'destroy' to tear down everything first"
        required: false
        default: ""

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-west-2
  TF_ROLE: arn:aws:iam::630943284793:role/alex-counter-service-terraform-ci
  CLUSTER_NAME: alex-counter-service-cluster
  ARGOCD_NAMESPACE: argocd
  APP_NAMESPACE: prod

jobs:
  # ── Stage 1: Infra (VPC, EKS, ECR, RDS) ────────────────────────────────────
  infra:
    name: "Terraform Infra"
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.TF_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.8.0"

      - name: Terraform Init (infra)
        working-directory: terraform/infra
        run: terraform init

      - name: Terraform Destroy (infra) — only when requested
        if: github.event.inputs.destroy == 'destroy'
        working-directory: terraform/infra
        run: terraform destroy -auto-approve
        env:
          TF_VAR_db_password: ${{ secrets.TF_VAR_DB_PASSWORD }}

      - name: Terraform Apply (infra)
        working-directory: terraform/infra
        run: terraform apply -auto-approve
        env:
          TF_VAR_db_password: ${{ secrets.TF_VAR_DB_PASSWORD }}

      - name: Export infra outputs
        working-directory: terraform/infra
        run: |
          echo "CLUSTER_ENDPOINT=$(terraform output -raw cluster_endpoint)" >> $GITHUB_ENV
          echo "RDS_ENDPOINT=$(terraform output -raw rds_endpoint)"         >> $GITHUB_ENV
          echo "BACKEND_ECR=$(terraform output -raw backend_ecr_url)"       >> $GITHUB_ENV
          echo "FRONTEND_ECR=$(terraform output -raw frontend_ecr_url)"     >> $GITHUB_ENV

  # ── Stage 2: App layer (IAM, ALB controller, CloudFront) ────────────────────
  app-terraform:
    name: "Terraform App"
    runs-on: ubuntu-latest
    needs: infra

    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.TF_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.8.0"

      - name: Terraform Init (app)
        working-directory: terraform/app
        run: terraform init

      - name: Terraform Apply (app)
        working-directory: terraform/app
        run: terraform apply -auto-approve

  # ── Stage 3: Install Argo CD ─────────────────────────────────────────────────
  argocd-install:
    name: "Install Argo CD"
    runs-on: ubuntu-latest
    needs: infra

    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.TF_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name   ${{ env.CLUSTER_NAME }}

      - name: Create argocd namespace
        run: kubectl create namespace ${{ env.ARGOCD_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Install / upgrade Argo CD
        run: |
          kubectl apply -n ${{ env.ARGOCD_NAMESPACE }} \
            --server-side --force-conflicts \
            -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

      - name: Wait for Argo CD to be ready
        run: |
          kubectl rollout status deployment/argocd-server \
            -n ${{ env.ARGOCD_NAMESPACE }} \
            --timeout=180s

      - name: Ensure default AppProject exists
        run: |
          kubectl apply -f - <<'EOF'
          apiVersion: argoproj.io/v1alpha1
          kind: AppProject
          metadata:
            name: default
            namespace: argocd
          spec:
            sourceRepos:
              - "*"
            destinations:
              - namespace: "*"
                server: https://kubernetes.default.svc
            clusterResourceWhitelist:
              - group: "*"
                kind: "*"
          EOF

  # ── Stage 4: Seed Kubernetes secrets + deploy via Argo CD ───────────────────
  deploy:
    name: "Deploy App"
    runs-on: ubuntu-latest
    needs: [app-terraform, argocd-install]

    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.TF_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name   ${{ env.CLUSTER_NAME }}

      - name: Read RDS endpoint from Terraform state
        run: |
          cd terraform/infra
          terraform init -input=false
          echo "RDS_ENDPOINT=$(terraform output -raw rds_endpoint)" >> $GITHUB_ENV
          echo "BACKEND_ECR=$(terraform output -raw backend_ecr_url)"  >> $GITHUB_ENV
          echo "FRONTEND_ECR=$(terraform output -raw frontend_ecr_url)" >> $GITHUB_ENV

      - name: Create prod namespace
        run: kubectl create namespace ${{ env.APP_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create / update backend-db secret
        run: |
          kubectl create secret generic backend-db \
            --namespace=${{ env.APP_NAMESPACE }} \
            --from-literal=DB_PASSWORD=${{ secrets.TF_VAR_DB_PASSWORD }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create / update backend-config ConfigMap
        run: |
          kubectl create configmap backend-config \
            --namespace=${{ env.APP_NAMESPACE }} \
            --from-literal=DB_HOST=${{ env.RDS_ENDPOINT }} \
            --from-literal=DB_PORT=5432 \
            --from-literal=DB_NAME=counter \
            --from-literal=DB_USER=counter \
            --from-literal=OTEL_SERVICE_NAME=counter-backend \
            --from-literal=OTEL_ENV=prod \
            --from-literal=OTEL_ENABLED=false \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply Argo CD Application
        run: kubectl apply -f manifests/argocd/application.yaml

      - name: Trigger Argo CD sync
        run: |
          kubectl -n ${{ env.ARGOCD_NAMESPACE }} wait \
            --for=condition=available deployment/argocd-server \
            --timeout=120s

          # Get admin password
          ARGOCD_PASSWORD=$(kubectl -n ${{ env.ARGOCD_NAMESPACE }} get secret argocd-initial-admin-secret \
            -o jsonpath="{.data.password}" | base64 -d)

          # Install argocd CLI
          curl -sSL -o /usr/local/bin/argocd \
            https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd

          # Port-forward in background for CLI login
          kubectl port-forward svc/argocd-server -n ${{ env.ARGOCD_NAMESPACE }} 8080:443 &
          sleep 5

          argocd login localhost:8080 \
            --username admin \
            --password "$ARGOCD_PASSWORD" \
            --insecure

          argocd app sync counter-service --force || true

      - name: Summary
        run: |
          echo "## Bootstrap complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---|---|" >> $GITHUB_STEP_SUMMARY
          echo "| Cluster | ${{ env.CLUSTER_NAME }} |" >> $GITHUB_STEP_SUMMARY
          echo "| RDS | ${{ env.RDS_ENDPOINT }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend ECR | ${{ env.BACKEND_ECR }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend ECR | ${{ env.FRONTEND_ECR }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Argo CD UI: run \`kubectl port-forward svc/argocd-server -n argocd 8080:443\`" >> $GITHUB_STEP_SUMMARY
